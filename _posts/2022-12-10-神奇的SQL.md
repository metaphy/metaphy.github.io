---
layout: post
title: "神奇的SQL"
date: 2022-12-10 11:25:00 +0800
categories: SQL
--- 
SQL绝对被人低估了，至少被我低估了。SQL是那种你可以投入少量时间却能获得较大收益的技术，也就是说边际效用极大。SQL具有很强的稳定性，尽管随着时间的推移有不少新的版本发布，但是基本功能几乎没怎么变化，两个主要版本SQL92和SQL99距今都二三十年了。SQL的稳定性能够让你一次性投入而长时间获得收益，相比某些前端技术或某些短命的框架而言，简直是一本万利的买卖。SQL又具有一定的难度，对于某些复杂操作，或者某些常见的坑（比如三值逻辑运算），不经过一定时间的学习，很难轻松掌握和面对。

如果把编程范式粗略地划分成命令式和函数式的话，SQL应该归于函数式这一类；但SQL处理的对象是集合，其数学基础是关系代数和集合论。这一点让SQL跟其他语言非常不同，你没法从其他编程经验中直接获得SQL的编写经验，也就是说，SQL是编程世界中比较特立独行的一个分支，需要花费时间认真对待。

下面以例子解释SQL的编写，主要参考日本作者Mick的《SQL进阶教程（第2版）》，一个容易被人看不上的非常土的书名，但其实内容极好，豆瓣9.1评分。下面的所有例子和SQL均在MySQL8上执行验证过。

[例1]有一城市人口表如下：
```
DROP TABLE IF EXISTS dec_popu;
CREATE TABLE dec_popu (
  id INT PRIMARY KEY AUTO_INCREMENT,
  city VARCHAR (64) NOT NULL,
  gender VARCHAR(1) NOT NULL DEFAULT 'M',
  population INT NOT NULL DEFAULT 0
);

INSERT INTO dec_popu(city, gender, population) VALUES('贵阳市', 'M' , 26714);
INSERT INTO dec_popu(city, gender, population) VALUES('贵阳市', 'F' , 23134);
INSERT INTO dec_popu(city, gender, population) VALUES('六枝特区', 'M' , 3026);
INSERT INTO dec_popu(city, gender, population) VALUES('六枝特区', 'F' , 2926);
INSERT INTO dec_popu(city, gender, population) VALUES('德州市', 'M' , 23256);
INSERT INTO dec_popu(city, gender, population) VALUES('青岛市', 'M' , 24770);
INSERT INTO dec_popu(city, gender, population) VALUES('潍坊市', 'M' , 32005);
INSERT INTO dec_popu(city, gender, population) VALUES('潍坊市', 'F' , 12000);
INSERT INTO dec_popu(city, gender, population) VALUES('乐山市', 'M' , 19200);
INSERT INTO dec_popu(city, gender, population) VALUES('乐山市', 'F' , 10800);
```
要求：虽然表格中并没有省份信息，但是需要按照省份统计总人口。省份作为一种常识存在。这里练习使用CASE子句。

```
SELECT CASE
  WHEN city IN ('贵阳市','六枝特区') THEN '贵州'
  WHEN city IN ('德州市','青岛市','潍坊市' ) THEN '山东'
  WHEN city IN ('乐山市') THEN '四川'
  ELSE '未知'
  END AS province,
  SUM(population) AS Total
FROM dec_popu
GROUP BY province;
```

要求：以城市/男性人口/女性人口的格式统计数据。这里练习把CASE放到SUM函数中。

```
SELECT city,
  SUM(CASE WHEN gender = 'M' THEN population ELSE 0 END) AS population_male,
  SUM(CASE WHEN gender = 'F' THEN population ELSE 0 END) AS population_female
FROM dec_popu
GROUP BY city;
```

要求：按性别统计，表格中各性别总人数，山东省各性别总人数，山东省下面各市各性别总人数。

```
SELECT gender
  , SUM(population) AS Total
  , SUM(CASE WHEN city IN ('德州市') THEN population ELSE 0 END) AS DeZhouShi
  , SUM(CASE WHEN city IN ('青岛市') THEN population ELSE 0 END) AS QingDaoShi
  , SUM(CASE WHEN city IN ('潍坊市') THEN population ELSE 0 END) AS WeiFangShi
  , SUM(CASE WHEN city IN ('德州市','青岛市','潍坊市') 
        THEN population ELSE 0 END) AS ShanDongSheng
FROM dec_popu
GROUP BY gender;
```

要求：如果城市中只有1种性别的人口记录，那么选它，如果有2种性别的人口记录，那么就选男性的人口数据。这里可以看出CASE子句极大的灵活性。

```
SELECT city, 
  CASE WHEN COUNT(*) = 1 THEN MAX(population) 
  ELSE MAX(CASE WHEN gender = 'M' THEN population ELSE -1 END) END AS PopuMain
FROM dec_popu
GROUP BY city;
```

[例2]下面是课程表以及课程时间表：
```
DROP TABLE IF EXISTS dec_course;
CREATE TABLE dec_course (
  course_id INT PRIMARY KEY AUTO_INCREMENT,
  course_name VARCHAR (32) NOT NULL
);

INSERT INTO dec_course(course_name) VALUES('计算机基础');
INSERT INTO dec_course(course_name) VALUES('会计学');
INSERT INTO dec_course(course_name) VALUES('财务管理学');
INSERT INTO dec_course(course_name) VALUES('英语');

DROP TABLE IF EXISTS dec_course_schedule;
CREATE TABLE dec_course_schedule (
  id INT PRIMARY KEY AUTO_INCREMENT,
  course_id INT NOT NULL,
  schedule_month  VARCHAR(10)
);

INSERT INTO dec_course_schedule(course_id, schedule_month) VALUES(1, '2022-05');
INSERT INTO dec_course_schedule(course_id, schedule_month) VALUES(1, '2022-06');
INSERT INTO dec_course_schedule(course_id, schedule_month) VALUES(1, '2022-07');
INSERT INTO dec_course_schedule(course_id, schedule_month) VALUES(2, '2022-06');
INSERT INTO dec_course_schedule(course_id, schedule_month) VALUES(2, '2022-07');
INSERT INTO dec_course_schedule(course_id, schedule_month) VALUES(3, '2022-05');
INSERT INTO dec_course_schedule(course_id, schedule_month) VALUES(4, '2022-07');
```

要求：把每项课程在每个月是否开课表示出来。这里使用case把课程时间的行信息，转为列信息。
```
SELECT course_id, course_name,
  CASE WHEN course_id IN (SELECT course_id FROM dec_course_schedule WHERE schedule_month = '2022-05') THEN 'Yes' ELSE '-' END AS 'May',
  CASE WHEN course_id IN (SELECT course_id FROM dec_course_schedule WHERE schedule_month = '2022-06') THEN 'Yes' ELSE '-' END AS 'June',
  CASE WHEN course_id IN (SELECT course_id FROM dec_course_schedule WHERE schedule_month = '2022-07') THEN 'Yes' ELSE '-' END AS 'July'
FROM dec_course;
```
另一种实现方式：
```
SELECT c.course_name,
  CASE WHEN EXISTS (SELECT course_id FROM dec_course_schedule cs WHERE c.course_id = cs.course_id AND cs.schedule_month = '2022-05') THEN 'Yes' ELSE '-' END AS May,
  CASE WHEN EXISTS (SELECT course_id FROM dec_course_schedule cs WHERE c.course_id = cs.course_id AND cs.schedule_month = '2022-06') THEN 'Yes' ELSE '-' END AS June,
  CASE WHEN EXISTS (SELECT course_id FROM dec_course_schedule cs WHERE c.course_id = cs.course_id AND cs.schedule_month = '2022-07') THEN 'Yes' ELSE '-' END AS July
FROM dec_course c;
```

[例3]下面是学生与他们多次模拟考试成绩的一个记录表，成绩记录在列中。

```
DROP TABLE IF EXISTS dec_student_scores;
CREATE TABLE dec_student_scores (
  name VARCHAR (16) NOT NULL,
  score1 int,
  score2 int,
  score3 int
);

INSERT INTO dec_student_scores VALUES('sam', 123, 202, 153);
INSERT INTO dec_student_scores VALUES('andy', 251, 185, 132);
INSERT INTO dec_student_scores VALUES('tom', 214, 207, 111);
INSERT INTO dec_student_scores VALUES('judy', 203, 223, 198);
```

要求：找出各个同学的最高分数。这个可以直接使用MySQL支持的GREATEST(score1, score2, score3)函数实现，但我们尝试使用CASE的方式。

```
SELECT name, 
  CASE WHEN score_bigger > score3 THEN score_bigger ELSE score3 END AS max_score 
FROM (
  SELECT name, score3, 
    CASE WHEN score1 > score2 THEN score1 ELSE score2 END AS score_bigger
  FROM dec_student_scores
) tmp;
```
另一种实现方式：
```
SELECT name, 
  CASE WHEN score1 > (CASE WHEN score2 > score3 THEN score2 ELSE score3 END)
  THEN score1
  ELSE (CASE WHEN score2 > score3 THEN score2 ELSE score3 END) END AS max_score
FROM dec_student_scores;
```

要求：将各位同学的成绩以sam, judy, tom, andy的顺序排序。这里练习将CASE子句放到ORDER BY之中。
```
SELECT name, score1, score2, score3
FROM dec_student_scores
ORDER BY (
  CASE name 
    WHEN 'sam' THEN 1
    WHEN 'judy' THEN 2
    WHEN 'tom' THEN 3
    WHEN 'andy' THEN 4
  ELSE NULL 
  END  
);
```

要求：求表中name的笛卡尔积，去除(a, a)这样的元组。使用CROSS JOIN来求笛卡尔积。
```
SELECT A.name AS name1, B.name AS name2
FROM dec_student_scores A  
CROSS JOIN dec_student_scores B
  ON A.name <> B.name
ORDER BY A.name;
```

更进一步，要求(a, b)和(b, a) 这样的数据，只保留一条。这其实是在找两个元素的组合。
```
SELECT A.name AS name1, B.name AS name2
FROM dec_student_scores A 
INNER JOIN dec_student_scores B
  ON A.name < B.name
ORDER BY A.name;
```

[例4]下面是各个服务器在某些日期的工作负载。
 
``` 
DROP TABLE IF EXISTS dec_server_loads;
CREATE TABLE dec_server_loads (
  server VARCHAR (4) NOT NULL,
  sample_date date NOT NULL,
  loads int NOT NULL default 0
);

insert into dec_server_loads values ('A', '2022-05-01', 1000);
insert into dec_server_loads values ('A', '2022-05-02', 1200);
insert into dec_server_loads values ('A', '2022-05-03', 1300);
insert into dec_server_loads values ('A', '2022-05-04', 900);
insert into dec_server_loads values ('A', '2022-05-05', 1220);
insert into dec_server_loads values ('B', '2022-05-01', 1100);
insert into dec_server_loads values ('B', '2022-05-02', 1200);
insert into dec_server_loads values ('B', '2022-05-06', 1500);
insert into dec_server_loads values ('B', '2022-05-07', 2000);
insert into dec_server_loads values ('B', '2022-05-12', 1000);
insert into dec_server_loads values ('C', '2022-05-01', 2000);
insert into dec_server_loads values ('C', '2022-05-03', 1300);
insert into dec_server_loads values ('C', '2022-05-04', 1200);
insert into dec_server_loads values ('C', '2022-05-05', 1600);
```

要求：每条记录都有一个日期，如何把这个日期的前一天找出来？这里需要用到Window函数。

```
SELECT server, sample_date,
  MIN(sample_date) OVER (
    PARTITION BY server ORDER BY sample_date ASC 
    ROWS between 1 preceding AND 1 preceding
  ) AS last_date
FROM dec_server_loads;
```

更进一步，把这个日期找出来，并且把这个日期对应的负载数据查出来。这里可以把Window单独定义出来，这样可以在SQL查询中直接使用，保持SQL的简洁。

```
SELECT server, sample_date, loads,
  MIN(sample_date) OVER W AS last_date,
  MIN(loads) OVER W AS last_loads
FROM dec_server_loads
Window W AS (PARTITION BY server ORDER BY sample_date ASC 
  ROWS between 1 preceding AND 1 preceding);
```

[例5]下面是一个产品表，里面包含产品信息和价格信息。
```
DROP TABLE IF EXISTS dec_product;
CREATE TABLE dec_product (
  id INT PRIMARY KEY AUTO_INCREMENT,
  product_name VARCHAR(32) NOT NULL,
  price DECIMAL(10,2),
  remarks VARCHAR(32) default ''
);

INSERT INTO dec_product(product_name, price) values('Apple', 7.5);
INSERT INTO dec_product(product_name, price) values('Watermelon', 2);
INSERT INTO dec_product(product_name, price) values('Banana', 5);
INSERT INTO dec_product(product_name, price) values('Apple', 7.5);
INSERT INTO dec_product(product_name, price) values('Apple', 7.5);
INSERT INTO dec_product(product_name, price) values('Banana', 5);
INSERT INTO dec_product(product_name, price) values('Apple', 8);
INSERT INTO dec_product(product_name, price) values('Apple', 8.5);
INSERT INTO dec_product(product_name, price) values('Watermelon', 2.2);
INSERT INTO dec_product(product_name, price) values('Grape', 7.5);
INSERT INTO dec_product(product_name, price) values('Orange', 12);
INSERT INTO dec_product(product_name, price) values('Carrot', 2);
INSERT INTO dec_product(product_name, price) values('Tomato', 1);
INSERT INTO dec_product(product_name, price) values('Cherry', 20);
```

要求：上面表格中有多个重复数据(product_name & price)，选出那些重复的数据，选出id较大的作为重复数据。

```
SELECT * FROM dec_product p1
WHERE id > (
  SELECT MIN(p2.id) 
  FROM dec_product p2 
  WHERE p1.product_name = p2.product_name 
    AND p1.price = p2.price
);
```

要求：选出重复的数据，选出id较小的作为重复数据。练习使用EXCEPT来做集合的减法。

```
SELECT id FROM dec_product
EXCEPT
SELECT MAX(id) FROM dec_product
GROUP BY product_name, price;
```

要求：只要是重复了就选出来，比如有2条数据重复了，把这2条都选出来，而不是像上面那样只选出一条。这里注意EXISTS的用法，EXISTS非常神奇。

```
SELECT * FROM dec_product p1
WHERE EXISTS (
  SELECT 1 FROM (
    SELECT product_name, price, COUNT(*) AS cnt FROM dec_product 
    GROUP BY product_name, price
  ) p2
  WHERE p2.cnt > 1 
    AND p1.product_name = p2.product_name 
    AND p1.price = p2.price
);
```

要求：对所有产品按价格从高到低排序，注意这里有2种排序方式，如果第一名有2个，下一名是第三名的叫一般rank，下一名是第二的叫dense_rank.

```
SELECT product_name, price, 
  rank() over (ORDER BY price DESC) AS rank_1,
  dense_rank() over (ORDER BY price DESC) AS rank_2_dense
FROM dec_product;
```

另外一种实现方式，这里巧妙的使用了Count和Distinct Count作为排序序号。

```
SELECT p1.product_name, p1.price,
  (SELECT COUNT(p2.price) FROM dec_product p2 WHERE p2.price > p1.price) + 1 AS rank_1,
  (SELECT COUNT(DISTINCT p2.price) FROM dec_product p2 WHERE p2.price > p1.price) + 1 AS rank_2_dense
FROM dec_product p1
ORDER BY rank_1;
```

[例6]下面定义了一个用户表。

```
DROP TABLE IF EXISTS dec_user;
CREATE TABLE dec_user  ( 
  id INT PRIMARY KEY AUTO_INCREMENT,
  nickname VARCHAR(32) NOT NULL,
  age int,
  address VARCHAR(200) DEFAULT ''
);

INSERT INTO dec_user(nickname, age, address) VALUES ('Liubei', 34, 'Shu');
INSERT INTO dec_user(nickname, age, address) VALUES ('Guanyu', 32, 'Shu');
INSERT INTO dec_user(nickname, age, address) VALUES ('Zhangfei', 31, 'Shu');
INSERT INTO dec_user(nickname, age, address) VALUES ('Caocao', 35, 'Wei');
INSERT INTO dec_user(nickname, age, address) VALUES ('Zhangliao', 32, 'Wei');
INSERT INTO dec_user(nickname, address) VALUES ('Guojia', 'Wei');
```

要求：每个用户都有一个Age，查询蜀国中有某个年龄的人而在魏国中没有这个年龄的人。正常应该查出id 是 1和3的蜀国用户，年龄分别为31和34. 由于魏国有年龄字段是NULL的用户，所以下面的NOT IN 方式并不能得到正确结果。

```
--incorrect due to NULL age in 'Wei'
SELECT * FROM dec_user
WHERE address = 'Shu'
  AND age NOT IN (
    SELECT age FROM dec_user
    WHERE address = 'Wei'
  );
```

正确的做法应该使用**NOT EXISTS**而不是NOT IN:
```
SELECT * FROM dec_user u1
WHERE address = 'Shu'
  AND NOT EXISTS (
    SELECT * FROM dec_user u2 
    WHERE u1.age = u2.age AND u2.address = 'Wei'
  );
```

注意：使用ORDER BY Age，NULL的数据将会排在前面。使用COALESCE函数将NULL数据转换为其他数据。
```
SELECT id, nickname, age FROM dec_user 
ORDER BY age;

SELECT id, nickname, COALESCE(age, -1) FROM dec_user;
```

注意：使用concat函数连接一个字符串和NULL，将会得到NULL
```
SELECT concat('Hello ', NULL) AS result FROM dual;
```

[例7]下面是一个会议出席人员表。

```
DROP TABLE IF EXISTS dec_meeting;
CREATE TABLE dec_meeting (
  meeting_id CHAR(4) not null,
  person VARCHAR(32) not null
);

INSERT INTO dec_meeting values('M1', 'ZhangFei');
INSERT INTO dec_meeting values('M1', 'LuSu');
INSERT INTO dec_meeting values('M1', 'Hu Dong');
INSERT INTO dec_meeting values('M2', 'ZhangFei');
INSERT INTO dec_meeting values('M2', 'XiaHouYuan');
INSERT INTO dec_meeting values('M3', 'LuSu');
INSERT INTO dec_meeting values('M3', 'Hu Dong');
INSERT INTO dec_meeting values('M3', 'XiaHouYuan');
```

要求：选出每次会议缺席的人。以这个表的Distinct person作为所有人员的集合。这里使用这个表自身的CROSS JOIN得到所有会议与所有人员的一个笛卡尔积，里面当然有重复的。使用这个集合去减原始的参会人员表，就会得到未参会人员表。这里可以看出来，NOT EXISTS与集合减法(EXCEPT)概念相近。

```
SELECT DISTINCT T1.meeting_id, T2.person 
FROM dec_meeting T1 CROSS JOIN dec_meeting T2  
WHERE NOT EXISTS (
  SELECT 1 FROM dec_meeting T3
  WHERE T1.meeting_id = T3.meeting_id 
    AND T2.person = T3.person
);
```

于是，你直接使用EXCEPT也可以：
```
SELECT DISTINCT T1.meeting_id, T2.person 
FROM dec_meeting T1 CROSS JOIN dec_meeting T2  
EXCEPT SELECT meeting_id, person FROM dec_meeting;
```

[例8]下面是又一个学生科目与成绩的表格。

```
DROP TABLE IF EXISTS dec_test_scores;
CREATE TABLE dec_test_scores (
  student_id INT NOT NULL,
  gender CHAR(1) NOT NULL,
  subject VARCHAR (16) NOT NULL,
  score int
);

INSERT INTO dec_test_scores values (1, 'F', '数学', 100);
INSERT INTO dec_test_scores values (1, 'F', '语文', 80);
INSERT INTO dec_test_scores values (1, 'F', '理化', 80);
INSERT INTO dec_test_scores values (2, 'F', '数学', 80);
INSERT INTO dec_test_scores values (2, 'F', '语文', 95);
INSERT INTO dec_test_scores values (3, 'M', '数学', 40);
INSERT INTO dec_test_scores values (3, 'M', '语文', 90);
INSERT INTO dec_test_scores values (3, 'M', '社会', 55);
INSERT INTO dec_test_scores values (4, 'M', '数学', 80);
INSERT INTO dec_test_scores values (5, 'F', '数学', 56);
INSERT INTO dec_test_scores values (5, 'F', '语文', 68);
INSERT INTO dec_test_scores values (5, 'F', '社会', 88);
INSERT INTO dec_test_scores values (6, 'M', '数学', 99);
INSERT INTO dec_test_scores values (6, 'M', '社会', 55); 
INSERT INTO dec_test_scores values (7, 'M', '数学', 92);
INSERT INTO dec_test_scores values (7, 'M', '语文', 85);
```

要求：查找学生，学生的全部科目成绩均大于等于60. 此处依然练习使用NOT EXISTS.

```
SELECT DISTINCT student_id 
FROM dec_test_scores t1
WHERE NOT EXISTS (
  SELECT 1 FROM dec_test_scores t2
  WHERE t1.student_id = t2.student_id
    AND t2.score < 60
);
```

要求：查找学生，学生拥有语文和数学成绩，并且语文成绩>=60, 数学成绩>=80.

```
SELECT student_id FROM dec_test_scores t1
WHERE subject IN ('数学', '语文') 
  AND NOT EXISTS (
    SELECT 1 FROM dec_test_scores t2
    WHERE t1.student_id = t2.student_id
      AND 1 = CASE WHEN subject = '数学' AND score < 80 THEN 1 
          WHEN subject = '语文' AND score < 60 THEN 1 
          ELSE 0 END
  )
GROUP BY student_id
HAVING COUNT(1) > 1;
```

ChatGPT给出的答案：
```
SELECT student_id
FROM dec_test_scores
WHERE subject IN ('语文', '数学')
  GROUP BY student_id HAVING COUNT(DISTINCT subject) = 2
  AND MIN(CASE WHEN subject = '数学' THEN score END) >= 80
  AND MIN(CASE WHEN subject = '语文' THEN score END) >= 60;
```

要求：哪个分数是出现次数最多的,出现几次? 深入体验GROUP BY的法.

```
SELECT score, COUNT(*) AS max_cnt 
FROM dec_test_scores  
GROUP BY score
HAVING max_cnt >= (
  SELECT MAX(cnt) FROM (
    SELECT COUNT(*) AS cnt FROM dec_test_scores 
    GROUP BY score
  ) T1
);
```

要求：哪门课程，其中至少75%的学生成绩大于等于80分？
```
SELECT subject FROM dec_test_scores
GROUP by subject 
HAVING SUM(CASE WHEN score >= 80 then 1 else 0 END) >= COUNT(*) * 3 / 4;
```

要求：哪门课程，男生及格的人数大于女生及格人数？
```
SELECT subject FROM dec_test_scores
GROUP BY subject
HAVING SUM(CASE WHEN score >=60 AND gender = 'M' THEN 1 ELSE 0 END) 
  > SUM(CASE WHEN score >=60 AND gender = 'F' THEN 1 ELSE 0 END) ;
```

要求：哪门课程，女生的平均分大于男生的平均分？注意：此处else部分用NULL而不是0，用NULL可以确保在计算avg时候不包含在内；即求avg时，对于NULL的记录，不会包含在分母里。
```
SELECT subject FROM dec_test_scores
GROUP BY subject
HAVING AVG(CASE WHEN gender = 'F' THEN score ELSE NULL END) 
  > AVG(CASE WHEN gender = 'M' THEN score ELSE NULL END);
```

[例9]下面是一个seq表。
```
DROP TABLE IF EXISTS dec_seq;
CREATE TABLE dec_seq (
  seq int NOT NULL,
  name VARCHAR(16) NOT NULL default ''
);
```

要求：快速插入1~100这100个数字.

```
INSERT INTO dec_seq(seq)
SELECT 1 + ones.id + 10 * tens.id AS number 
FROM (
    SELECT 0 AS id
    UNION SELECT 1  
    UNION SELECT 2 
    UNION SELECT 3  
    UNION SELECT 4  
    UNION SELECT 5  
    UNION SELECT 6  
    UNION SELECT 7  
    UNION SELECT 8  
    UNION SELECT 9
  ) ones CROSS JOIN (
    SELECT 0 AS id
    UNION SELECT 1  
    UNION SELECT 2 
    UNION SELECT 3  
    UNION SELECT 4  
    UNION SELECT 5  
    UNION SELECT 6  
    UNION SELECT 7  
    UNION SELECT 8  
    UNION SELECT 9
  ) tens;
```

[例10]下面是城市仓库储存原材料的表，列是城市，入库日期和材料。
```
DROP TABLE IF EXISTS dec_materials;
CREATE TABLE dec_materials(
  center VARCHAR(16) not null,
  in_date date, 
  material VARCHAR(4)
);

INSERT INTO dec_materials values ('Beijing', '2018-04-01', '锡');
INSERT INTO dec_materials values ('Beijing', '2018-04-12', '锌');
INSERT INTO dec_materials values ('Beijing', '2018-05-17', '铝');
INSERT INTO dec_materials values ('Beijing', '2018-05-20', '锌');
INSERT INTO dec_materials values ('Shanghai', '2018-04-20', '铜');
INSERT INTO dec_materials values ('Shanghai', '2018-04-22', '镍');
INSERT INTO dec_materials values ('Shanghai', '2018-04-29', '铅');
INSERT INTO dec_materials values ('Tianjin', '2018-03-15', '钛');
INSERT INTO dec_materials values ('Tianjin', '2018-04-01', '钢');
INSERT INTO dec_materials values ('Tianjin', '2018-04-24', '钢');
INSERT INTO dec_materials values ('Tianjin', '2018-05-02', '镁');
INSERT INTO dec_materials values ('Tianjin', '2018-05-10', '钛');
INSERT INTO dec_materials values ('Dalian', '2018-05-10', '锌');
INSERT INTO dec_materials values ('Dalian', '2018-05-28', '锡');
```

要求：哪些城市对某种原料有多于1次的入库？




[例11]

[例12]

[例13]

[例14]

[例15]
-------------------


  
``` 
-- Query duplicated materials City
SELECT center FROM DEC_MATERIALS
GROUP BY center
HAVING COUNT(material) > COUNT(DISTINCT material);

SELECT center, 
  CASE WHEN COUNT(material) > COUNT(DISTINCT material) THEN 'Duplicated Material' ELSE 'No' END AS duplicated
FROM DEC_MATERIALS
GROUP BY center;

-- which shop owns all the items
SELECT s.shop FROM DEC_SHOP_ITEMS s INNER JOIN DEC_ITEMS i
ON s.item = i.item
GROUP BY s.shop
HAVING COUNT(s.item) = (SELECT COUNT(item) FROM DEC_ITEMS);

-- which shop exactly owns the items (no more no less)
SELECT s.shop FROM DEC_SHOP_ITEMS s LEFT OUTER JOIN DEC_ITEMS i
ON s.item = i.item 
GROUP BY s.shop
HAVING COUNT(s.item) = (SELECT COUNT(item) FROM DEC_ITEMS)
   AND COUNT(i.item) = (SELECT COUNT(item) FROM DEC_ITEMS);

-- the college whose student all submit IN September
SELECT dpt FROM (
  SELECT dpt, 
    CASE WHEN sbmt_date >= '2018-09-01' AND sbmt_date < '2018-10-01' THEN 1 ELSE 0 END AS sbmt_date_ind 
  FROM DEC_SUB) t1
GROUP BY dpt 
HAVING COUNT(*) = SUM(sbmt_date_ind);

--OR
SELECT dpt FROM DEC_SUB
GROUP BY dpt
HAVING COUNT(*) = SUM(CASE WHEN YEAR(sbmt_date) = 2018 AND MONTH(sbmt_date) = 9 THEN 1 ELSE 0 END);

-- list the my item COUNT AND the diff COUNT:
SELECT shop, COUNT(item) AS my_item_cnt, (SELECT COUNT(*) FROM DEC_ITEMS) - COUNT(item) AS diff_cnt 
FROM (
  SELECT s.shop, i.item FROM DEC_SHOP_ITEMS s LEFT OUTER JOIN DEC_ITEMS i
  ON s.item = i.item
) t1
GROUP BY shop ;

-- sales analytics WITH last year
SELECT S1.year, S1.sale AS current_sale, S2.sale AS last_year_sale, S1.sale - S2.sale
FROM DEC_SALE S1 LEFT OUTER JOIN DEC_SALE S2
ON S1.year = S2.year + 1;

SELECT year, sale AS current_sale, 
  SUM(sale) OVER (ORDER BY year range between 1 preceding AND 1 preceding) AS last_year_sale
FROM DEC_SALE; 

-- Make sure you understand the difference of Range Between / Rows Between
SELECT year, sale AS current_sale, 
  SUM(sale) OVER (ORDER BY year rows between 1 preceding AND 1 preceding) AS last_year_sale
FROM DEC_SALE; 

SELECT year, last_year_sale, sale AS current_sale,
  CASE WHEN sale > last_year_sale THEN '↑'
  WHEN sale = last_year_sale THEN '→'
  ELSE '↓' END AS trENDing
FROM(  
  SELECT year, sale, 
    SUM(sale) OVER (ORDER BY year rows between 1 preceding AND 1 preceding) AS last_year_sale
  FROM DEC_SALE
)t1;

--the price > avg (price) of the same product type
SELECT * FROM DEC_PRODUCTS A
WHERE price > (SELECT avg(price)
  FROM DEC_PRODUCTS B
  WHERE A.product_type = B.product_type
  GROUP BY product_type
);

SELECT product_name, product_type, price, avg_price
FROM (
  SELECT product_name, product_type, price,
    avg(price) OVER (partition by product_type) AS avg_price  
  FROM DEC_PRODUCTS )TMP1
WHERE price > avg_price;

--query per page:
SELECT product_name, product_type, price, row_num, total_count FROM (
SELECT product_name, product_type, price,
    ROW_NUMBER() OVER(ORDER BY product_type, product_name) AS row_num,
    COUNT(*) OVER () AS total_count
FROM DEC_PRODUCTS ) T1
WHERE row_num between 1 AND 5;

--check OVER booked reservations
SELECT * FROM DEC_RESERVATIONS A
WHERE EXISTS(
 SELECT * FROM DEC_RESERVATIONS B
 WHERE A.reserver <> B.reserver
   AND (A.start_date between B.start_date AND B.END_date
   OR A.END_date between  B.start_date AND B.END_date)
);

SELECT *
FROM (SELECT reserver, start_date, END_date, 
 MAX(start_date) OVER (ORDER BY start_date rows between 1 following AND 1 following) AS next_start_date,
 MAX(reserver) OVER (ORDER BY start_date rows between 1 following AND 1 following) AS next_reserver
FROM DEC_RESERVATIONS)T1
WHERE next_start_date between start_date AND END_date;

--check the avg amount of pre 2 AND current row
SELECT prc_date, prc_amt, 
  avg(prc_amt) OVER (ORDER BY prc_date rows between 2 preceding AND current row) AS avg
FROM DEC_ACCOUNTS;

--use join to implete the avg amout of of pre 2 AND current row
WITH acc AS ( 
SELECT (@row_number:=@row_number + 1) AS seq, t.prc_date, t.prc_amt
FROM DEC_ACCOUNTS t, (SELECT @row_number:=0) AS r)
---------define a temporary table WITH rownum AS above
SELECT alt.*, 
  CASE WHEN alt.amt2 is NULL THEN alt.amt1
  WHEN alt.amt3 is NULL THEN (alt.amt1 + alt.amt2)/2
  ELSE (alt.amt1 + alt.amt2 + alt.amt3)/3 END AS avg_amt
FROM (SELECT acc.seq, acc.prc_date, acc.prc_amt AS amt1, acc2.prc_amt AS amt2, acc3.prc_amt AS amt3
  FROM acc LEFT OUTER JOIN acc acc2
    ON acc.seq = acc2.seq + 1
  LEFT OUTER JOIN acc acc3
   ON acc.seq = acc3.seq +2
) alt;

--Another way to use the join to implete the avg amout of of pre 2 AND current row
SELECT prc_date, A1.prc_amt, (
  SELECT avg(prc_amt) FROM DEC_ACCOUNTS A2
  WHERE A1.prc_date >= A2.prc_date
    AND(
      SELECT COUNT(*) FROM DEC_ACCOUNTS A3 
      WHERE A3.prc_date between A2.prc_date AND A1.prc_date) <=3) AS mvg_SUM
FROM DEC_ACCOUNTS A1
ORDER BY prc_date;

--student AND courses
SELECT t0.name
  ,(SELECT 'O' FROM DEC_STUDENT_COURSES t1 WHERE t0.name = t1.name AND course = 'SQL') AS 'SQL'
  ,(SELECT 'O' FROM DEC_STUDENT_COURSES t2 WHERE t0.name = t2.name AND course = 'UNIX') AS 'UNIX'
  ,(SELECT 'O' FROM DEC_STUDENT_COURSES t3 WHERE t0.name = t3.name AND course = 'Java') AS 'Java'
FROM (SELECT DISTINCT name FROM DEC_STUDENT_COURSES) t0 ;

SELECT name, 
  CASE WHEN SUM(CASE WHEN course = 'SQL' THEN 1 ELSE NULL END) >= 1 THEN 'O' ELSE NULL END AS 'SQL',
  CASE WHEN SUM(CASE WHEN course = 'UNIX' THEN 1 ELSE NULL END) >= 1 THEN 'O' ELSE NULL END AS 'UNIX',
  CASE WHEN SUM(CASE WHEN course = 'Java' THEN 1 ELSE NULL END) >= 1 THEN 'O' ELSE NULL END AS 'Java'
FROM DEC_STUDENT_COURSES
GROUP BY name;

-- cols ==> rows
SELECT name, child_1 AS child FROM  DEC_PERSONNEL
union
SELECT name, child_2 AS child FROM  DEC_PERSONNEL
union
SELECT name, child_3 AS child FROM  DEC_PERSONNEL;

SELECT p.name, vc.child
FROM DEC_PERSONNEL p LEFT OUTER JOIN DEC_V_PERSONNEL vc
ON vc.child IN (p.child_1, p.child_2, p.child_3);

-- FULL OUTER JOIN -- mysql doesn't support it
/* SELECT COALESCE(a.id, b.id) AS id, a.name AS a_name, b.name AS b_name
FROM DEC_NAMEA a FULL OUTER JOIN DEC_NAMEB b
ON a.id = b.id; */
-- use LEFT OUTER JOIN UNION right outer join to replace FULL OUTER JOIN
SELECT a.id AS id, a.name AS a_name, b.name AS b_name
FROM DEC_NAMEA a LEFT OUTER JOIN DEC_NAMEB b
ON a.id = b.id
union
SELECT b.id AS id, a.name AS a_name, b.name AS b_name
FROM DEC_NAMEA a right outer join DEC_NAMEB b
ON a.id = b.id;

--use below AS a Merge IN MySQL
insert into DEC_NAMEA
SELECT id, name FROM DEC_NAMEB
  ON DUPLICATE KEY UPDATE DEC_NAMEA.name = DEC_NAMEB.name;
  
--check if two tables are the same.  change the "3" to which is reasonable
SELECT 
 CASE WHEN COUNT(*) = 3 THEN 'A AND B are the same' ELSE 'NOT same' END 
FROM (SELECT  * FROM DEC_NAMEA   union 
     SELECT * FROM DEC_NAMEB) tmp;
 
--another method to check if two tables are the same
SELECT CASE WHEN COUNT(*) = 0 THEN 'The same' ELSE 'NOT same' END AS result
FROM
((SELECT * FROM DEC_NAMEA UNION SELECT * FROM DEC_NAMEB)
EXCEPT  
(SELECT * FROM DEC_NAMEA INTERSECT SELECT * FROM DEC_NAMEB)) t1;

--check who have all the skills required IN the course table
SELECT DISTINCT emp FROM  DEC_EMP_SKILLS t1
WHERE NOT EXISTS (
  SELECT skill FROM DEC_COURSES
  EXCEPT
  SELECT t2.skill FROM DEC_EMP_SKILLS t2
  WHERE t1.emp = t2.emp
);

--compare which supplier supplies the same parts 
SELECT s1.sup AS sup1, s2.sup AS sup2 
FROM DEC_SUP s1, DEC_SUP s2
WHERE s1.sup < s2.sup 
  AND s1.part = s2.part
GROUP BY s1.sup, s2.sup
HAVING COUNT(*) = (SELECT COUNT(*) FROM DEC_SUP s3 WHERE s1.sup = s3.sup)
   AND COUNT(*) = (SELECT COUNT(*) FROM DEC_SUP s4 WHERE s2.sup = s4.sup);

--query AND search for the emp who hAS exactly the skill defined IN DEC_COURSES
SELECT emp, 
CASE WHEN COUNT(skill_e) = COUNT(skill_c) AND COUNT(skill_e) = (SELECT COUNT(*) FROM DEC_COURSES) THEN 'Y' ELSE 'N' END AS result
FROM(
  SELECT emp, e.skill AS skill_e, c.skill AS skill_c 
  FROM DEC_EMP_SKILLS e LEFT OUTER JOIN  DEC_COURSES c
  ON e.skill = c.skill) tmp
GROUP BY emp
HAVING result = 'Y';

--the answer FROM the book regarding above questions:
SELECT emp FROM  DEC_EMP_SKILLS t1
WHERE NOT EXISTS (
  SELECT skill FROM DEC_COURSES
  EXCEPT
  SELECT t2.skill FROM DEC_EMP_SKILLS t2
  WHERE t1.emp = t2.emp
)
GROUP BY emp
HAVING COUNT(*) = (SELECT COUNT(*) FROM DEC_COURSES);

--another way to that
SELECT DISTINCT emp FROM DEC_EMP_SKILLS t1
WHERE NOT EXISTS (
  SELECT skill FROM DEC_COURSES
  EXCEPT
  SELECT t2.skill FROM DEC_EMP_SKILLS t2
  WHERE t1.emp = t2.emp
) 
AND NOT EXISTS (
  SELECT t2.skill FROM DEC_EMP_SKILLS t2
  WHERE t1.emp = t2.emp
  EXCEPT
  SELECT skill FROM DEC_COURSES
);

--area of seats 
SELECT a.seat, '~', b.seat
FROM DEC_SEATS a, DEC_SEATS b
WHERE b.seat = a.seat + (3 - 1)
  AND NOT EXISTS (
    SELECT * FROM DEC_SEATS c
    WHERE c.seat between a.seat AND b.seat
      AND c.status <> ''
  );
  
SELECT seat, '~', END_seat
FROM (SELECT seat, MAX(seat) OVER (ORDER BY seat rows between 2 following AND 2 following) AS END_seat
  FROM DEC_SEATS 
  WHERE status = ''
)t1
WHERE END_seat = seat + 2;


update dec_doctor_info 
set region_name = COALESCE(
   (SELECT MAX(F2.region_name) FROM dec_doctor_info F2
   INNER JOIN dec_account_info A ON F2.account_key= A.account_key
   WHERE F2.region_name <> ''
     AND F2.ta = dec_doctor_info.ta
     AND A.primary_parent_account_key = (
	  SELECT A2.primary_parent_account_key FROM dec_account_info A2
	  WHERE A2.account_key = dec_doctor_info.account_key
     )
   )
  , '-'
)
WHERE region_name = '';




UPDATE dec_doctor_info 
SET region_name = COALESCE(
   (SELECT MAX(F2.region_name) FROM 
   (SELECT * FROM dec_doctor_info) F2
   INNER JOIN dec_account_info A ON F2.account_key= A.account_key
   WHERE F2.region_name <> ''
     AND F2.ta = dec_doctor_info.ta
     AND A.primary_parent_account_key = (
      SELECT A2.primary_parent_account_key FROM dec_account_info A2
      WHERE A2.account_key = dec_doctor_info.account_key
     )
   )
  , '-')
WHERE region_name = '';
 ```