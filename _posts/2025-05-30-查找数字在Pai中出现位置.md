---
layout: post
title:  "查找数字在Pai中出现位置"
date:   2025-05-30 21:00:00 +0800
categories: rust
---

之前使用Go编程实现查找数字在Pai中出现位置【[在这里](https://metaphy.github.io/go/2019/01/15/你的银行卡密码出现在Pi的什么位置.html)】，查找10亿位的Pai文件。这次使用Rust多线程实现。Rust擅长命令行程序的编写，因此也编译成命令行模式。 

先分析源代码。 

```
fn find_pai_from_current_dir() -> Result<String, Box<dyn Error>> {  // 1.1
    let current_dir = env::current_dir().unwrap();
    
    let entries = match fs::read_dir(&current_dir) {
        Ok(entries) => entries,
        Err(e) => {
            eprintln!("Error reading directory: {}", e);
            return Err(Box::new(e));
        }
    };

    for entry in entries {
        match entry {
            Ok(entry) => {
                let path = entry.path();
                if path.is_file() && path.file_name().and_then(|s| s.to_str())  // 1.2
                        .map_or(false, |s| s.split(std::path::MAIN_SEPARATOR).last()
                            .map_or(false, |name| name.starts_with("pi-") && name.ends_with(".txt"))) {
                    return Ok(path.to_string_lossy().into_owned());
                }
            },
            Err(e) => eprintln!("Error reading entry: {}", e),
        }
    }
    Err(Box::from("PAI file not found in the current directory"))
}
```

**标记1.1** 这个函数是寻找默认pai文件。当命令行没有显式提供pai文件位置，它自动从当前目录寻找  

**标记1.2** 这里使用的是and_then, and_then作用于Option，对Option中值自动提取，所以path.file_name()返回的是Option，而闭包中|s|部分的s是解Option后的&OsStr； Rust设计之时没有空值，对可能出错之处就使用Option，这点与Java/Go非常不一样，后者需要不停判断 xyz != Null / xyz != Nil。


 
```
impl Params {       // 2.1
    pub fn new(search_number: String, pai_file: String) -> Self {
        Params { search_number, pai_file }
    } 

    pub fn check_params(&self) -> Result<(), String> {
        // make sure the search_number are all number characters
        if !self.search_number.chars().all(|c| c.is_digit(10)) {
            return Err("Search number must contain only digits".to_string());
        }
        // make sure the pai_file exists 
        if !std::path::Path::new(&self.pai_file).exists() {
            return Err(format!("PAI file does not exist: {}", self.pai_file));
        }

        Ok(())
    }
}
```
  
**标记2.1** 这里是定义参数结构的，并加方法check_params 


```
const DEFAULT_THREADS_COUNT: usize = 10;        // 3.1
const DEFAULT_BLOCK_SIZE: usize = 4096;

pub fn run(params: Params) -> Result<i64, String> {
    params.check_params()?; 

    let mut threads = vec![];
    let shared_result = Arc::new(RwLock::new(usize::MAX));

    for thread_id in 0..DEFAULT_THREADS_COUNT {
        let pai_file_path = params.pai_file.clone();
        let search_number = params.search_number.clone();
        let shared_result = Arc::clone(&shared_result);

        let handle = thread::spawn(move || {
            if let Err(e) = process_blocks(thread_id, &search_number, &pai_file_path, shared_result) {
                eprintln!("Thread {} encountered an error: {}", thread_id, e);
            }  
        });
        threads.push(handle);
    }
    
    for t in threads {
        t.join().expect("A thread panicked");
    } 
    
    let result = *shared_result.read().unwrap();
    if result == usize::MAX {
        Ok(-1)  // Not found
    } else {
        Ok(result as i64) 
    }
}
```
  
**标记3.1** 这一段是启动线程的方法，关于线程数和每次读取Block的size配置，需要着重说一下。在同样搜索000000~000999时，不同配置差别很大。其中横轴是线程数配置，纵轴是每次读取文本长度配置，中间是找这1000个数字花费的时间(秒)。因为本机是M4 10核+10显卡核，所以总体看10个线程是最快的，这个没有问题。为什么配置每次读取1M却变慢了呢？这是因为查找的6位数字基本在很靠前的位置就找到了，比如log中显示的000990到000999，最多也就位于2 million的位置，你一个线程读入1 million位，完全发挥不了多线虫同时搜索的优势。另外，按照下面最快的配置，找完100万个数字需要 3.5*1000 sec，大约58分钟(实际运行还真是58分钟)

```
Search 000990, found it at: 2368408
Search 000991, found it at: 162536
Search 000992, found it at: 495206
Search 000993, found it at: 95967
Search 000994, found it at: 1069448
Search 000995, found it at: 115749
Search 000996, found it at: 48497
Search 000997, found it at: 1954924
Search 000998, found it at: 1341375
Search 000999, found it at: 357702
```

| * | 1个线程 | 2个线程 | 4个线程 | 10个线程 | 16个线程 |
| ---- | ---- | ---- | ---- | ---- | ---- |  
| 1 KB | 14.3 | 7.5 | 4.3 |3.7 | 4.6 | 
| 2 KB |14.3 | 7.4 | 4.1 | 3.5 | 4.4 |
| 4 KB | 14.1 | 7.3 | 4.1 | 3.5 | 4.4 |
| 16 KB | 14.2 | 7.3 | 4.2 | 3.6 | 4.4 |
| 1024 KB | 14.0 | 13.7 | 15.0 | 22.3 | 28.4 |

 